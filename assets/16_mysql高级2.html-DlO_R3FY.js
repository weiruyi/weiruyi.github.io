import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as d,a as i,d as l,w as o,b as n,e,o as r}from"./app-D7gfXBqy.js";const p="/image/mysql/mysql12.png",c="/image/mysql/mysql13.png",u="/image/mysql/mysql14.png",h="/image/mysql/mysql16.png",g="/image/mysql/mysql17.png",_="/image/mysql/mysql18.png",m="/image/mysql/mysql19.png",f="/image/mysql/mysql20.png",b="/image/mysql/mysql21.png",y="/image/mysql/mysql22.png",B="/image/mysql/mysql15.png",k="/image/mysql/mysql23.png",L="/image/mysql/mysql24.png",D="/image/mysql/mysql25.png",I="/image/mysql/mysql26.png",R="/image/mysql/mysql27.png",v="/image/mysql/mysql28.png",x="/image/mysql/mysql29.png",P={},q=n(`<h1 id="mysql高级二" tabindex="-1"><a class="header-anchor" href="#mysql高级二"><span>MySQL高级二</span></a></h1><h2 id="一、锁" tabindex="-1"><a class="header-anchor" href="#一、锁"><span>一、锁</span></a></h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><ul><li>InnoDB按照锁的粒度分为以下三类： <ul><li>行级锁：每次操作锁住一条行数据</li><li>表级锁：每次操作锁住整张表</li><li>全局锁：锁定数据库中的所有表</li></ul></li><li>MyISAM、Memory等引擎仅支持表级锁，且不支持事务，因此适用于只读或以读为主的场景</li></ul><h3 id="_1、全局锁" tabindex="-1"><a class="header-anchor" href="#_1、全局锁"><span>1、全局锁</span></a></h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><ul><li>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</li></ul><p><strong>语法:</strong></p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">-- 加锁</span>
flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span> <span class="token punctuation">;</span>

<span class="token comment">-- 数据备份</span>
mysqldump <span class="token operator">-</span>uroot –p1234 itcast <span class="token operator">&gt;</span> itcast<span class="token punctuation">.</span><span class="token keyword">sql</span>

<span class="token comment">-- 释放锁</span>
<span class="token keyword">unlock</span> <span class="token keyword">tables</span> <span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，我们可以在备份时加上参数 <code>--single-transaction</code> 参数来完成不加锁的一致性数据备份。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code>mysqldump <span class="token comment">--single-transaction -uroot –p123456 itcast &gt; itcast.sql</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_2、表级锁" tabindex="-1"><a class="header-anchor" href="#_2、表级锁"><span>2、表级锁</span></a></h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><p>表锁</p></li><li><p>元数据锁（meta data lock，MDL）</p></li><li><p>意向锁</p></li></ul><h4 id="_1-表锁" tabindex="-1"><a class="header-anchor" href="#_1-表锁"><span>1)表锁</span></a></h4><p>对于表锁，分为两类：</p><ul><li><p>表共享读锁（read lock）</p></li><li><p>表独占写锁（write lock）</p></li></ul><p>语法：</p><ul><li><p>加锁：<code>lock tables 表名... read/write;</code></p></li><li><p>释放锁：<code>unlock tables; / 客户端断开连接 </code></p></li></ul><p><strong>读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。</strong></p><h4 id="_2-元数据锁" tabindex="-1"><a class="header-anchor" href="#_2-元数据锁"><span>2)元数据锁</span></a></h4><p>元数据锁 meta data lock , 元数据锁，简写MDL。MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免<strong>DML</strong>与 <strong>DDL</strong>冲突，保证读写的正确性。</p><blockquote><p>这里的元数据，大家可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。</p></blockquote><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加<strong>MDL读锁(共享)</strong>；当对表结构进行变更操作的时候，加<strong>MDL写锁(排他)</strong>。</p><p>具体SQL语句的加锁如下：</p><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read /write</td><td>SHARED_READ_ONLY /SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select, select ... lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select ... for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table ...</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><p>查看当前数据库中的加锁情况：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code> <span class="token keyword">select</span> object_type<span class="token punctuation">,</span> object_schema<span class="token punctuation">,</span> object_name<span class="token punctuation">,</span>lock_type<span class="token punctuation">,</span> lock_duration <span class="token keyword">from</span> performance_schema<span class="token punctuation">.</span>metadata_locks<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_3-意向锁" tabindex="-1"><a class="header-anchor" href="#_3-意向锁"><span>3)意向锁</span></a></h4><p>为了避免DML在执行时，加的行锁与表锁冲突造成性能降低，InnoDB中引入了意向锁 Intention Lock，使得表锁不用遍历每行记录是否加锁。引入意向锁后，如果一个客户端对某一行加上了行锁，那么系统会<strong>自动对其加上意向锁</strong>，当别的客户端试图对其加上表锁时，便会检查意向锁是否兼容，若是不兼容，便会阻塞直到意向锁释放。</p><p><strong>分类</strong></p><ul><li>意向共享锁（IS）：Intention Shared Lock，当事务准备在某条记录上加S锁时，需要先在表级别加IS锁</li><li>意向排他锁（lX）：Intention Exclusive Lock，当事务准备在某条记录上加X锁时，需要先在表级别加IX锁</li></ul><p><strong>表锁兼容性</strong></p><table><thead><tr><th>兼容性</th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>注：意向锁之间不会互斥。一旦事务提交，IS、IX 都会自动释放。</p><h3 id="_3、行级锁" tabindex="-1"><a class="header-anchor" href="#_3、行级锁"><span>3、行级锁</span></a></h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</li><li>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</li><li>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</li></ul><h4 id="_1-行锁" tabindex="-1"><a class="header-anchor" href="#_1-行锁"><span>1)行锁</span></a></h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li><p>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p></li><li><p>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p></li></ul><p><strong>共享锁之间相互兼容，排它锁与任何锁都不兼容。</strong></p><p><strong>记录锁SQL语句</strong></p><table><thead><tr><th>SQL</th><th>记录锁类型</th><th>说明</th></tr></thead><tbody><tr><td>insert</td><td>隐式锁</td><td>一般情况不加记录锁</td></tr><tr><td>update</td><td>X锁</td><td>自动加锁</td></tr><tr><td>delete</td><td>X锁</td><td>自动加锁</td></tr><tr><td>select</td><td>不加锁</td><td></td></tr><tr><td>SELECT ... LOCK IN SHARE MODE</td><td>S锁</td><td>需手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT ... FOR UPDATE</td><td>X锁</td><td>需手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><h4 id="_2-间隙锁" tabindex="-1"><a class="header-anchor" href="#_2-间隙锁"><span>2)间隙锁</span></a></h4><p>Gap Locks（LOCK_GAP）间隙锁对索引记录间隙（不含该记录）加锁，确保索引记录间隙不变，防止其他事务在这个间隙插入新记录。</p>`,50),E=e("img",{src:p,style:{zoom:"50%"}},null,-1),M=e("ul",null,[e("li",null,"Gap锁唯一目的是为了防止产生幻读"),e("li",null,"Gap锁可以共存，不会限制其它事务在同一间隙上加任何行锁"),e("li",null,"如果要对索引末尾加Gap锁，可以对Supremum伪记录加Gap锁")],-1),S=e("h4",{id:"_3-临键锁",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_3-临键锁"},[e("span",null,"3)临键锁")])],-1),C=e("p",null,"Next-Key Locks（LOCK_ORDINARY）临键锁是记录锁和间隙锁的组合，同时锁住数据和数据前面的间隙。",-1),A=e("img",{src:c,style:{zoom:"50%"}},null,-1),w=n('<ul><li>在Repeatable Read隔离级别下支持</li><li>默认情况下InnoDB使用临键锁进行搜索和索引扫描，以防止幻读。</li><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。</li><li>索引上的等值查询（普通索引），向右遍历，最后一个值不满足查询需求时，临键锁退化为间隙锁。</li></ul><p>此外，还有插入意向锁（Insert Intention Locks）用于向加了gap锁的间隙插入新记录时的等待状态，隐式锁依赖事务id保证插入记录的安全</p><h2 id="二、innodb引擎" tabindex="-1"><a class="header-anchor" href="#二、innodb引擎"><span>二、InnoDB引擎</span></a></h2><h3 id="_1、逻辑存储结构" tabindex="-1"><a class="header-anchor" href="#_1、逻辑存储结构"><span>1、逻辑存储结构</span></a></h3><p>InnoDB的逻辑存储结构如下图所示:</p>',5),T=e("img",{src:u,style:{zoom:"50%"}},null,-1),U=n('<ul><li>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</li><li>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</li><li>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li><li>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行，InnoDB 存储引擎数据是按行进行存放的。在行中，默认有两个隐藏字段： <ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul></li></ul><h3 id="_2、innodb记录格式" tabindex="-1"><a class="header-anchor" href="#_2、innodb记录格式"><span>2、InnoDB记录格式</span></a></h3><p>InnoDB设计了四种行格式：<code>Compact, Redundant, Dynamic, Compressed</code>，可以在创建或修改的表语句中指定<code>ROW_FORMAT</code>，默认Dynamic行格式。</p><h4 id="_1-compact行格式" tabindex="-1"><a class="header-anchor" href="#_1-compact行格式"><span>1)Compact行格式</span></a></h4>',4),Q=e("img",{src:h,style:{zoom:"50%"}},null,-1),V=n("<p>一条完整的记录分为<code>记录的额外信息</code>和<code>记录的真实数据</code>两部分组成。</p><ul><li>记录的额外信息 <ul><li><strong>变长字段长度列表</strong>：非NULL的变长字段/可变字符集字段的实际长度，按列逆序存放，每列占1~2个字节</li><li><strong>NULL值列表</strong>：允许NULL的列的标志位，1为NULL，0非NULL，按列逆序，高位用0补齐至整字节。</li><li><strong>记录头信息</strong>：固定的5个字节组成</li></ul></li></ul>",2),O=e("img",{src:g,style:{zoom:"50%"}},null,-1),F=n('<ul><li>记录的真实数据：真实列数据，以及三个隐藏字段 <ul><li><strong>row_id</strong>: 可选，没有主键/Unique字段的记录，引擎默认生成该隐藏列作为主键</li><li><strong>transaction_id</strong>: 最后一次插入或更新该行的事务 id</li><li><strong>roll_pointer</strong>: 回滚指针，指向该行的 undo log</li></ul></li></ul><h4 id="_2-redundant行格式" tabindex="-1"><a class="header-anchor" href="#_2-redundant行格式"><span>2)Redundant行格式</span></a></h4><p>MySQL 5.0 之前使用的行格式</p>',3),z=e("img",{src:_,style:{zoom:"50%"}},null,-1),N=n('<h4 id="_3-行溢出" tabindex="-1"><a class="header-anchor" href="#_3-行溢出"><span>3)行溢出</span></a></h4><ul><li>对于定长字段，无论真实数据大小，都会占用固定大小的空间，用0/空格补齐</li><li>VARCHAR类型最多占用65535字节，但还依赖于字符集、列的限制等</li><li>对于Compact和Redundant，如果某一列数据过大，只会存储该列前768个字节，然后用20个字节指向存储溢出数据的另一个页</li><li>MySQL规定一个页中至少存放两行记录，以及列的数量，都会影响行溢出的临界点</li></ul><h4 id="_4-dynamic-和-compressed-行格式" tabindex="-1"><a class="header-anchor" href="#_4-dynamic-和-compressed-行格式"><span>4)Dynamic 和 Compressed 行格式</span></a></h4><p>MySQL 8.0 默认行格式就是<code>Dynamic</code>，与Compact类似，区别在于行溢出时，真实数据处仅有一个指针，指针存储所有数据字节的其它页。而<code>Compressed</code>会采用压缩算法对页面进行压缩，以节省空间</p><h3 id="_3、innodb数据页" tabindex="-1"><a class="header-anchor" href="#_3、innodb数据页"><span>3、InnoDB数据页</span></a></h3><p>InnoDB设计了多种类型的页，存放不同的信息，其中存放表中记录的是数据页，也称索引页（InnoDB中索引即数据）。</p>',6),H=e("img",{src:m,style:{zoom:"33%"}},null,-1),X=n('<table><thead><tr><th>名称</th><th>中文名</th><th>占用空间大小</th><th>描述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38字节</td><td>页的一些通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56字节</td><td>数据页专有的一些信息</td></tr><tr><td>Infimum + Supremum</td><td>最小记录和最大记录</td><td>26不确定</td><td>两个虚拟行记录</td></tr><tr><td>User Records</td><td>用户记录</td><td>不确定</td><td>实际存储的行记录内容</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页面目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8字节</td><td>校验页是否完整</td></tr></tbody></table><h4 id="_1-user-records" tabindex="-1"><a class="header-anchor" href="#_1-user-records"><span>1)User Records</span></a></h4><p>每插入一条记录，都会从<code>Free Space</code>分配一条记录的空间给<code>User Records</code>，Free Space分配完毕则该页使用完毕。<strong>若干个记录以及两个伪记录按主键大小串成一个单链表</strong></p>',3),W=e("img",{src:f,style:{zoom:"50%"}},null,-1),G=n('<p>其中每条记录的记录头部分：</p><ul><li>delete_mask: <ul><li>标记当前记录是否被删除</li><li>删除后仅修改标志位和链表指针，记录空间成为可重用空间</li><li>插入新纪录时会复用可重用空间</li></ul></li><li><strong>min_rec_mask</strong>: B+树每层非叶子结点的最小记录</li><li><strong>n_owned</strong>: 该记录组所含的记录数，见页目录部分</li><li>heap_no: <ul><li>当前记录在本页中的位置</li><li>其中0、1对应最小(<code>Infimum</code>)和最大(<code>Supremum</code>)的伪记录</li><li>完整记录之间根据主键大小排序。</li></ul></li><li>record_type: 当前记录类型 <ul><li>0 普通记录</li><li>1 为B+树非叶节点记录</li><li>2 最小记录(即<code>Infimum</code>伪记录)</li><li>3 最大记录(即<code>Supremum</code>伪记录)。</li></ul></li><li><strong>next_record</strong>: 当前记录真实数据到下一条记录真实数据的地址偏移量 (按列逆序放置正是为了提高缓冲命中率)</li></ul><h4 id="_2-page-directory" tabindex="-1"><a class="header-anchor" href="#_2-page-directory"><span>2)Page Directory</span></a></h4><p>对整个单链表查找记录性能低，因此采取分组索引策略：</p><ul><li>所有正常记录 (包括最小、最大记录，排除已删除记录) 划分为若干组</li><li>每组最后一条记录（即最大记录）的头记录中的<code>n_owned</code>标记该组内记录数</li><li>每组最后一条记录的地址偏移量抽取成索引，存放在<code>Page Directory</code>中构成页目录，其中每个偏移量称为槽</li></ul><p>槽的更新：</p><ul><li>初始时仅<code>Infimum</code>和<code>Supremum</code>两个组</li><li>每插入一条记录，从页目录中找到主键值大于本记录的最小槽，然后把该槽的<code>n_owned</code>加一，直到该组内记录达到8条</li><li>一个组内的记录达到8条后，再次插入新记录时，将该组拆分为一个4条记录的组和一个5条记录的组，并新增对应的槽</li></ul>',7),K=e("img",{src:b,style:{zoom:"50%"}},null,-1),Z=n('<p>因此，查找时:</p><ul><li>通过二分法确定该记录所在的槽，并借助前一个槽找到所在槽中主键值最小的记录</li><li>通过记录的<code>next_record</code>遍历该槽查找记录</li></ul><h4 id="_3-其它部分" tabindex="-1"><a class="header-anchor" href="#_3-其它部分"><span>3)其它部分</span></a></h4><ul><li><strong>Page Header</strong>: 针对数据页，存储本页记录的状态信息，占56字节</li><li><strong>File Header</strong>: 针对所有页，存储页的通用信息，如前后页指针构成双链表，占38字节</li><li><strong>File Trailer</strong>: 针对所有页，用于同步正确性检验，占8字节，前4字节校验和，后四字节日志序列位置LSN</li></ul>',4),j=e("img",{src:y,style:{zoom:"50%"}},null,-1),Y=e("h3",{id:"_4、架构",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_4、架构"},[e("span",null,"4、架构")])],-1),J=e("p",null,"MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。",-1),$=e("img",{src:B,style:{zoom:"50%"}},null,-1),ee=n(`<h4 id="_1-内存结构" tabindex="-1"><a class="header-anchor" href="#_1-内存结构"><span>1)内存结构</span></a></h4><p>在左侧的内存结构中，主要分为这么四大块儿： <code>Buffer Pool</code>、<code>Change Buffer</code>、<code>Adaptive Hash Index</code>、<code>Log Buffer</code>。 接下来介绍一下这四个部分。</p><ul><li><strong>Buffer Pool</strong></li></ul><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li><p>free page：空闲page，未被使用。</p></li><li><p>clean page：被使用page，数据没有被修改过。</p></li><li><p>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</p></li></ul><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： <code>show variables like &#39;innodb_buffer_pool_size&#39;;</code></p><ul><li><strong>Change Buffer</strong></li></ul><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><div class="hint-container info"><p class="hint-container-title">相关信息</p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p></div><ul><li><strong>Adaptive Hash Index</strong></li></ul><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成</strong>。参数：<code> adaptive_hash_index</code></p><ul><li><strong>Log Buffer</strong></li></ul><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p><p>参数:</p><ul><li><p><code>innodb_log_buffer_size</code>：缓冲区大小</p></li><li><p><code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机，取值主要包含以下三个：</p><ul><li>1: 日志在每次事务提交时写入并刷新到磁盘，默认值。</li><li>0: 每秒将日志写入并刷新到磁盘一次。</li><li>2: 日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li></ul></li></ul><h4 id="_2-磁盘结构" tabindex="-1"><a class="header-anchor" href="#_2-磁盘结构"><span>2)磁盘结构</span></a></h4><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构.</p><ul><li><strong>System Tablespace</strong></li></ul><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><p>参数：<code>innodb_data_file_path</code></p><p>系统表空间默认的文件名叫 ibdata1。</p><ul><li><p><strong>File-Per-Table Tablespaces</strong></p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p></li></ul><p>开关参数：<code>innodb_file_per_table</code> ，该参数默认开启。</p><ul><li><strong>General Tablespaces</strong></li></ul><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">--  创建表空间</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLESPACE</span> ts_name <span class="token keyword">ADD</span> DATAFILE <span class="token string">&#39;file_name&#39;</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> engine_name<span class="token punctuation">;</span>

<span class="token comment">-- 创建表时指定表空间</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> xxx <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">TABLESPACE</span> ts_name<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>Undo Tablespaces</strong></li></ul><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><ul><li><strong>Temporary Tablespaces</strong></li></ul><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><ul><li><strong>Doublewrite Buffer Files</strong></li></ul><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><ul><li><strong>Redo Log</strong></li></ul><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件:<code>ib_logfile0,ib_logfile1</code></p><h4 id="_3-后台线程" tabindex="-1"><a class="header-anchor" href="#_3-后台线程"><span>3)后台线程</span></a></h4><p>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。</p>`,42),te=e("img",{src:k,style:{zoom:"25%"}},null,-1),le=n(`<p>在InnoDB的后台线程中，分为4类，分别是：<code>Master Thread</code> 、<code>IO Thread</code>、<code>Purge Thread</code>、<code>Page Cleaner Thread</code>。</p><ul><li><strong>Master Thread</strong></li></ul><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收</p><ul><li><strong>IO Thread</strong></li></ul><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Wrie thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">engine</span> <span class="token keyword">innodb</span> <span class="token keyword">status</span> \\G<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>Purge Thread</strong></li></ul><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><ul><li><strong>Page Cleaner Thread</strong></li></ul><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h2 id="三、buffer-pool详解" tabindex="-1"><a class="header-anchor" href="#三、buffer-pool详解"><span>三、Buffer Pool详解</span></a></h2><h3 id="_1、为什么要有-buffer-pool" tabindex="-1"><a class="header-anchor" href="#_1、为什么要有-buffer-pool"><span>1、为什么要有 Buffer Pool？</span></a></h3><p>虽然说 MySQL 的数据是存储在磁盘里的，但是也不能每次都从磁盘里面读取数据，这样性能是极差的。要想提升查询性能，加个缓存就行了嘛。所以，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>`,16),oe=e("img",{src:L,style:{zoom:"25%"}},null,-1),ne=n('<p>有了缓冲池后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li></ul><div class="hint-container tip"><p class="hint-container-title">缓冲池有多大?</p><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。</p></div><h3 id="_2、buffer-pool缓存什么" tabindex="-1"><a class="header-anchor" href="#_2、buffer-pool缓存什么"><span>2、Buffer Pool缓存什么</span></a></h3><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的默认大小为 16KB。因此，Buffer Pool 同样需要按「页」来划分。</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页，Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>所以，MySQL 刚启动的时候，你会观察到使用的虚拟内存空间很大，而使用到的物理内存空间却很小，这是因为只有这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系。</p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。</p><p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p>',10),se=e("img",{src:D,style:{zoom:"50%"}},null,-1),ae=n('<p>上图中控制块和缓存页之间灰色部分称为碎片空间。</p><blockquote><p>为什么会有碎片空间呢？</p><p>每一个控制块都对应一个缓存页，那在分配足够多的控制块和缓存页后，可能剩余的那点儿空间不够一对控制块和缓存页的大小，自然就用不到喽，这个用不到的那点儿内存空间就被称为碎片了。</p><p>当然，<strong>如果你把 Buffer Pool 的大小设置的刚刚好的话，也可能不会产生碎片。</strong></p></blockquote><blockquote><p>查询一条记录，就只需要缓冲一条记录吗？</p><p>不是的。当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</p></blockquote><h3 id="_3、如何管理-buffer-pool" tabindex="-1"><a class="header-anchor" href="#_3、如何管理-buffer-pool"><span>3、如何管理 Buffer Pool？</span></a></h3><h4 id="_1-如何管理空闲页" tabindex="-1"><a class="header-anchor" href="#_1-如何管理空闲页"><span>1)如何管理空闲页？</span></a></h4><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p><p>那当我们从磁盘读取数据的时候，总不能通过遍历这一片连续的内存空间来找到空闲的缓存页吧，这样效率太低了。</p><p>所以，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）。</p>',8),de=e("img",{src:I,style:{zoom:"50%"}},null,-1),ie=n('<ul><li><p>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</p></li><li><p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</p></li><li><p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free 链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</p></li></ul><h4 id="_2-如何管理脏页" tabindex="-1"><a class="header-anchor" href="#_2-如何管理脏页"><span>2)如何管理脏页？</span></a></h4><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p><p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p><p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p><h4 id="_3-如何提高缓存命中率" tabindex="-1"><a class="header-anchor" href="#_3-如何提高缓存命中率"><span>3)如何提高缓存命中率？</span></a></h4><p>Buffer Pool 的大小是有限的，对于一些频繁访问的数据我们希望可以一直留在 Buffer Pool 中，而一些很少访问的数据希望可以在某些时机可以淘汰掉，从而保证 Buffer Pool 不会因为满了而导致无法再缓存新的数据，同时还能保证常用数据留在 Buffer Pool 中。</p><p>要实现这个，最容易想到的就是 <strong>LRU（Least recently used）算法</strong>。</p><p>该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。</p><p>简单的 LRU 算法的实现思路是这样的：</p><ul><li>当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。</li><li>当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。</li></ul>',11),re=e("img",{src:R,style:{zoom:"50%"}},null,-1),pe=n('<p>图中：</p><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于 LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。</li></ul><p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p><ul><li><p>预读失效；</p></li><li><p>Buffer Pool 污染；</p><p><strong>(a)预读失效</strong></p></li></ul><blockquote><p>什么是预读失效？</p><p>先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p><p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p><p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool 空间不够的时候，还需要把末尾的页淘汰掉。如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。</p></blockquote><div class="hint-container tip"><p class="hint-container-title">怎么解决预读失效而导致缓存命中率降低的问题？</p><p>我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，局部性原理还是成立的。</p><p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p></div><p><strong>那到底怎么才能避免呢？</strong></p><p>MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：</p>',8),ce=e("img",{src:v,style:{zoom:"50%"}},null,-1),ue=n(`<ul><li>old 区域占整个 LRU 链表长度的比例可以通过 <code>innodb_old_blocks_pct</code> 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。</li></ul><p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><p><strong>(b) Buffer Pool污染</strong></p><p>虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是 <strong>Buffer Pool 污染</strong>的问题。</p><blockquote><p>什么是 Buffer Pool 污染？</p><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p><p>注意，Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。</p></blockquote><p>比如，在一个数据量非常大的表，执行了这条语句：</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">&quot;%xiaolin%&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：</p><ul><li>从磁盘读到的页加入到 LRU 链表的 old 区域头部；</li><li>当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；</li><li>接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；</li><li>如此往复，直到扫描完表中的所有记录。</li></ul><p>经过这一番折腾，原本 young 区域的热点数据都会被替换掉。</p><p><strong>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</strong></p><p>像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。</p><p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong>。</p><p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul><p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p><ul><li><p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题。</p></li><li><p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。<strong>young 区域前面 1/4 被访问不会移动到链表头部</strong>，只有后面的 3/4 被访问了才会。</p></li></ul><h4 id="_4-脏页什么时候会被刷入磁盘" tabindex="-1"><a class="header-anchor" href="#_4-脏页什么时候会被刷入磁盘"><span>4)脏页什么时候会被刷入磁盘？</span></a></h4><p>引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。</p><p>可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？</p><p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，<strong>即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</strong></p><p>下面几种情况会触发脏页的刷新：</p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程回定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul><p>在我们开启了慢 SQL 监控后，如果你发现**「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。</p><p>如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。</p><div class="hint-container important"><p class="hint-container-title">总结</p><p>1、Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>2、Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p><p>3、Innodb 通过三种链表来管理缓页：</p><ul><li>Free List（空闲页链表），管理空闲页；</li><li>Flush List（脏页链表），管理脏页；</li><li>LRU List，管理脏页 + 干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。</li></ul><p>4、InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p><ul><li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li><li>当 <strong>「页被访问」且「old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为 1 秒）」</strong> 时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li></ul><p>5、可以通过调整 <code>innodb_old_blocks_pct</code> 参数，设置 young 区域和 old 区域比例。</p></div><h2 id="四、事务原理" tabindex="-1"><a class="header-anchor" href="#四、事务原理"><span>四、事务原理</span></a></h2><h3 id="_1、事务基础" tabindex="-1"><a class="header-anchor" href="#_1、事务基础"><span>1、事务基础</span></a></h3><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><div class="hint-container tip"><p class="hint-container-title">事务特性</p><ul><li><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</p></li><li><p>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</p></li><li><p>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p></li><li><p>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</p></li></ul></div><p>我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><p>而对于这四大特性，实际上分为两个部分。</p><ul><li>原子性、一致性、持久性，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。</li><li>隔离性是通过数据库的锁，加上MVCC来保证的。</li></ul><h4 id="_1-redo-log" tabindex="-1"><a class="header-anchor" href="#_1-redo-log"><span>1)redo log</span></a></h4><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的<strong>两个redolog文件是循环写的</strong>。</p><blockquote><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p></blockquote><h4 id="_2-undo-log" tabindex="-1"><a class="header-anchor" href="#_2-undo-log"><span>2)undo log</span></a></h4><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p></li><li><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment。</p></li></ul><h3 id="_2、mvcc基本概念" tabindex="-1"><a class="header-anchor" href="#_2、mvcc基本概念"><span>2、MVCC基本概念</span></a></h3><h4 id="_1-当前读" tabindex="-1"><a class="header-anchor" href="#_1-当前读"><span>1)当前读</span></a></h4><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p>对于我们日常的操作，如：<code>select ... lock in share mode</code>(共享锁)，<code>select ... for update</code>、<code>update</code>、<code>insert</code>、<code>delete</code>(排他锁)都是一种当前读。</p><h4 id="_2-快照读" tabindex="-1"><a class="header-anchor" href="#_2-快照读"><span>2)快照读</span></a></h4><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committed：每次select，都生成一个快照读。</p></li><li><p>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</p></li><li><p>Serializable：快照读会退化为当前读。</p></li></ul><h4 id="_3-mvcc" tabindex="-1"><a class="header-anchor" href="#_3-mvcc"><span>3)MVCC</span></a></h4><p>全称<code> Multi-Version Concurrency Control</code>，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的<strong>三个隐式字段、undo log日志、readView</strong>。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从而来介绍一下MVCC的原理。</p><h3 id="_3、隐藏字段" tabindex="-1"><a class="header-anchor" href="#_3、隐藏字段"><span>3、隐藏字段</span></a></h3><p>创建表的时候InnoDB会自动的给我们添加三个隐藏字段及其含义分别是</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本.</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><p>上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><h3 id="_4、undo-log" tabindex="-1"><a class="header-anchor" href="#_4、undo-log"><span>4、undo log</span></a></h3><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><p><strong>版本链:</strong></p><p>前面提到过，对记录的删改操作对应的Undo日志里有old roll pointer字段指向旧的Undo日志，从而构成一个记录的版本链。链表的头部就是当前记录的最新值。</p>`,59),he=e("img",{src:x,style:{zoom:"50%"}},null,-1),ge=n('<h3 id="_5、readview" tabindex="-1"><a class="header-anchor" href="#_5、readview"><span>5、readview</span></a></h3><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>生成ReadView时系统中活跃的读写事务的id列表</td></tr><tr><td>min_trx_id</td><td>生成ReadView时系统中活跃的读写事务最小id</td></tr><tr><td>max_trx_id</td><td>生成ReadView时系统应分配给下一个事务的id值（最大活跃事务id+1）</td></tr><tr><td>creator_trx_id</td><td>生成该ReadView的事务id（仅实际增删改时才分配，只读事务id默认0）</td></tr></tbody></table><p><strong>访问规则</strong> 有了ReadView后，查询过程会顺着版本链遍历，根据ReadView的访问规则，直到找到一条可访问的版本，或不含该记录。其中，trx_id为被访问版本的trx_id属性值：</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前事务自己更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明该版本在当前事务生成ReadView前已经提交</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该版本在当前事务生成ReadView后才开启</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果trx_id在m_ids中，不可以访问；否则可以访问</td><td>m_ids存在trx_id则说明该事务还是活跃的，不存在则说明该事务已提交</td></tr></tbody></table><p><strong>生成时机</strong> 对于READ_COMMITTED和REPEATABLE_READ，最大的区别在于它们生成ReadView的时机不同。也正因此，READ_COMMITTED无法禁止不可重复读问题。</p><ul><li>READ_COMMITTED事务每次SELECT查询前都会生成独立的ReadView</li><li>REPEATABLE_READ事务只在第一次SELECT查询前生成一个共享的ReadView</li></ul><p>另外，为了支持MVCC，insert undo日志在事务提交后即可释放，而update undo日志不能立即删除；删除时需要分两阶段，第一阶段仅做delete mark。</p><h3 id="_6、隔离级别" tabindex="-1"><a class="header-anchor" href="#_6、隔离级别"><span>6、隔离级别</span></a></h3><ul><li>RC隔离级别: RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</li><li>RR隔离级别: RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView,那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</li></ul><div class="hint-container important"><p class="hint-container-title">总结</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p></div>',12);function _e(me,fe){const t=a("center");return r(),d("div",null,[i("more-"),q,l(t,null,{default:o(()=>[E]),_:1}),M,S,C,l(t,null,{default:o(()=>[A]),_:1}),w,l(t,null,{default:o(()=>[T]),_:1}),U,l(t,null,{default:o(()=>[Q]),_:1}),V,l(t,null,{default:o(()=>[O]),_:1}),F,l(t,null,{default:o(()=>[z]),_:1}),N,l(t,null,{default:o(()=>[H]),_:1}),X,l(t,null,{default:o(()=>[W]),_:1}),G,l(t,null,{default:o(()=>[K]),_:1}),Z,l(t,null,{default:o(()=>[j]),_:1}),Y,J,l(t,null,{default:o(()=>[$]),_:1}),ee,l(t,null,{default:o(()=>[te]),_:1}),le,l(t,null,{default:o(()=>[oe]),_:1}),ne,l(t,null,{default:o(()=>[se]),_:1}),ae,l(t,null,{default:o(()=>[de]),_:1}),ie,l(t,null,{default:o(()=>[re]),_:1}),pe,l(t,null,{default:o(()=>[ce]),_:1}),ue,l(t,null,{default:o(()=>[he]),_:1}),ge])}const Be=s(P,[["render",_e],["__file","16_mysql高级2.html.vue"]]),ke=JSON.parse('{"path":"/posts/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/16_mysql%E9%AB%98%E7%BA%A72.html","title":"MySQL高级二","lang":"zh-CN","frontmatter":{"title":"MySQL高级二","date":"2024-11-22T16:14:58.000Z","category":"数据库","tag":"mysql","icon":"/img/mysql.svg","order":16,"description":"MySQL高级二 一、锁 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。 InnoDB按照锁的粒度分为以下三类： 行级锁：每次操作锁...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/16_mysql%E9%AB%98%E7%BA%A72.html"}],["meta",{"property":"og:site_name","content":"Lance"}],["meta",{"property":"og:title","content":"MySQL高级二"}],["meta",{"property":"og:description","content":"MySQL高级二 一、锁 锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。 InnoDB按照锁的粒度分为以下三类： 行级锁：每次操作锁..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-26T11:10:12.000Z"}],["meta",{"property":"article:author","content":"RuyiWei"}],["meta",{"property":"article:tag","content":"mysql"}],["meta",{"property":"article:published_time","content":"2024-11-22T16:14:58.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-26T11:10:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL高级二\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-11-22T16:14:58.000Z\\",\\"dateModified\\":\\"2024-11-26T11:10:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"RuyiWei\\"}]}"]]},"headers":[{"level":2,"title":"一、锁","slug":"一、锁","link":"#一、锁","children":[{"level":3,"title":"1、全局锁","slug":"_1、全局锁","link":"#_1、全局锁","children":[]},{"level":3,"title":"2、表级锁","slug":"_2、表级锁","link":"#_2、表级锁","children":[]},{"level":3,"title":"3、行级锁","slug":"_3、行级锁","link":"#_3、行级锁","children":[]}]},{"level":2,"title":"二、InnoDB引擎","slug":"二、innodb引擎","link":"#二、innodb引擎","children":[{"level":3,"title":"1、逻辑存储结构","slug":"_1、逻辑存储结构","link":"#_1、逻辑存储结构","children":[]},{"level":3,"title":"2、InnoDB记录格式","slug":"_2、innodb记录格式","link":"#_2、innodb记录格式","children":[]},{"level":3,"title":"3、InnoDB数据页","slug":"_3、innodb数据页","link":"#_3、innodb数据页","children":[]},{"level":3,"title":"4、架构","slug":"_4、架构","link":"#_4、架构","children":[]}]},{"level":2,"title":"三、Buffer Pool详解","slug":"三、buffer-pool详解","link":"#三、buffer-pool详解","children":[{"level":3,"title":"1、为什么要有 Buffer Pool？","slug":"_1、为什么要有-buffer-pool","link":"#_1、为什么要有-buffer-pool","children":[]},{"level":3,"title":"2、Buffer Pool缓存什么","slug":"_2、buffer-pool缓存什么","link":"#_2、buffer-pool缓存什么","children":[]},{"level":3,"title":"3、如何管理 Buffer Pool？","slug":"_3、如何管理-buffer-pool","link":"#_3、如何管理-buffer-pool","children":[]}]},{"level":2,"title":"四、事务原理","slug":"四、事务原理","link":"#四、事务原理","children":[{"level":3,"title":"1、事务基础","slug":"_1、事务基础","link":"#_1、事务基础","children":[]},{"level":3,"title":"2、MVCC基本概念","slug":"_2、mvcc基本概念","link":"#_2、mvcc基本概念","children":[]},{"level":3,"title":"3、隐藏字段","slug":"_3、隐藏字段","link":"#_3、隐藏字段","children":[]},{"level":3,"title":"4、undo log","slug":"_4、undo-log","link":"#_4、undo-log","children":[]},{"level":3,"title":"5、readview","slug":"_5、readview","link":"#_5、readview","children":[]},{"level":3,"title":"6、隔离级别","slug":"_6、隔离级别","link":"#_6、隔离级别","children":[]}]}],"git":{"createdTime":1732335752000,"updatedTime":1732619412000,"contributors":[{"name":"weiruyi","email":"1581778251@qq.com","commits":3}]},"readingTime":{"minutes":40.05,"words":12016},"filePathRelative":"posts/后端/数据库/16_mysql高级2.md","localizedDate":"2024年11月22日","excerpt":"<!--more--->\\n<h1>MySQL高级二</h1>\\n<h2>一、锁</h2>\\n<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p>\\n<ul>\\n<li>InnoDB按照锁的粒度分为以下三类：\\n<ul>\\n<li>行级锁：每次操作锁住一条行数据</li>\\n<li>表级锁：每次操作锁住整张表</li>\\n<li>全局锁：锁定数据库中的所有表</li>\\n</ul>\\n</li>\\n<li>MyISAM、Memory等引擎仅支持表级锁，且不支持事务，因此适用于只读或以读为主的场景</li>\\n</ul>","autoDesc":true}');export{Be as comp,ke as data};
